<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Pixy インサイト（UI）</title>
  <style>html{ -webkit-text-size-adjust: 100%; }

    :root{
      --bg:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --line:#f3a6c8;
      --chip:#e5e7eb;
      --chipText:#111827;
      --chipActive:#111111;
      --chipActiveText:#ffffff;
      --card:#ffffff;
      --cardBorder:#d1d5db;
      --cardActiveBg:#fde7ef;
      --cardActiveBorder:#f3a6c8;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 16px 14px 30px;
    }

    /* header cards */
    .topGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin: 10px 0 12px;
    }
    @media (max-width:700px){
      .topGrid{ grid-template-columns: 1fr; }
    }
    .topCard{
      background: linear-gradient(180deg,#fff, #fff);
      border:1px solid var(--cardBorder);
      border-radius: 14px;
      padding: 12px 12px 10px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .topCard.pink{
      background: #fde7ef;
      border-color:#f3a6c8;
    }
    .kpiTitle{
      font-size: 11px;
      color: var(--muted);
      font-weight: 700;
      letter-spacing:.02em;
      margin-bottom: 6px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .kpiValue{
      font-size: 24px;
      font-weight: 900;
      letter-spacing: .02em;
      line-height: 1.1;
    }
    .kpiSub{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(17,24,39,.06);
      font-weight: 800;
    }

    /* chips */
    .chipRow{
      display:flex;
      gap: 8px;
      margin: 6px 0 8px;
      flex-wrap:wrap;
    }
    .chip{
      border: none;
      padding: 8px 12px;
      border-radius: 999px;
      background: var(--chip);
      color: var(--chipText);
      font-weight: 900;
      font-size: 13px;
      cursor:pointer;
    }
    .chip.active{
      background: var(--chipActive);
      color: var(--chipActiveText);
    }

    /* chart card */
    .card{
      background: var(--card);
      border:1px solid var(--cardBorder);
      border-radius: 16px;
      padding: 12px 12px 10px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .cardTitle{
      font-weight: 950;
      font-size: 15px;
      letter-spacing:.01em;
    }
    .cardHint{
      font-size: 12px;
      font-weight: 800;
      color: var(--muted);
      white-space:nowrap;
    }

    /* svg chart */
    .chartArea{
      position:relative;
      height: 220px;
      border-radius: 12px;
      overflow:hidden;
      background:#fff;
    }
    svg{display:block; width:100%; height:100%;}
    .axisText{
      font-size: 11px;
      fill: var(--muted);
      font-weight: 800;
    }
    .gridLine{
      stroke: rgba(17,24,39,.12);
      stroke-dasharray: 3 5;
    }
    .pathFill{
      fill: rgba(37,99,235,.10);
    }
    .pathStroke{
      fill:none;
      stroke: rgba(37,99,235,1);
      stroke-width: 3;
    }
    .point{
      fill: #fff;
      stroke: rgba(37,99,235,1);
      stroke-width: 3;
    }
    .cursorLine{
      position:absolute; top: 8px; bottom: 8px; width:2px;
      background: rgba(37,99,235,.55); border-radius:999px;
      pointer-events:none; display:none; z-index: 18;
    }
    .tooltip{
      position:absolute; min-width: 90px; padding: 8px 10px;
      background:#fff; border:1px solid rgba(0,0,0,.08); box-shadow: 0 10px 30px rgba(0,0,0,.12);
      border-radius: 10px; font-size: 12px; font-weight:800; color: var(--text);
      transform: translate(-50%, -110%); pointer-events:none; display:none; white-space:nowrap; z-index: 20;
    }
    .tooltip b{font-size:18px; font-weight:950;}
    .tooltip .sub{display:block; font-size:12px; font-weight:900; color:var(--muted); margin-bottom:2px;}

    .xLabels{
      display:flex;
      justify-content:space-between;
      gap: 6px;
      padding: 8px 6px 2px;
      font-size: 12px;
      font-weight: 900;
      color: var(--muted);
    }
    .xLabels span{
      min-width: 26px;
      text-align:center;
      white-space:nowrap;
    }
    .yLabels{
      position:absolute; right: 6px; top: 8px; bottom: 8px;
      display:flex; flex-direction:column; justify-content:space-between;
      align-items:flex-end;
      font-size: 12px; font-weight: 900; color: var(--muted);
      pointer-events:none;
      z-index: 5;
    }
    .yLabels div{
      background: rgba(255,255,255,.8);
      padding: 0 4px;
      border-radius: 6px;
    }

    /* monthly selector */
    .monthRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-top: 10px;
    }
    .monthSelect{
      display:flex;
      gap: 10px;
      overflow:auto;
      padding:10px 0 2px;
      -webkit-overflow-scrolling: touch;
    }
    .monthBtn{
      flex: 0 0 auto;
      border:1px solid var(--cardBorder);
      background:#fff;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 950;
      min-width: 112px;
      text-align:center;
      box-shadow: 0 8px 20px rgba(0,0,0,.06);
    }
    .monthBtn.active{
      background: #fde7ef;
      border-color: var(--cardActiveBorder);
      color:#111;
    }
    .monthMeta{
      font-size: 12px;
      font-weight: 900;
      color: var(--muted);
      white-space:nowrap;
    }

    /* footer small */
    .note{
      margin-top: 12px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 700;
      line-height: 1.6;
    }
  </style>
</head>

<body>
<div class="wrap">

  <div class="topGrid">
    <div class="topCard pink" id="cardRev">
      <div class="kpiTitle">報酬金</div>
      <div class="kpiValue" id="kpiRev">—</div>
      <div class="kpiSub">
        <span class="badge">前月比 <span id="kpiMoM">—</span></span>
      </div>
    </div>

    <div class="topCard" id="cardCnt">
      <div class="kpiTitle">鑑定件数</div>
      <div class="kpiValue" id="kpiCnt">—</div>
    </div>

    <div class="topCard" id="cardUsers">
      <div class="kpiTitle">鑑定人数</div>
      <div class="kpiValue" id="kpiUsers">—</div>
    </div>
  </div>

  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">報酬金</div>
      <div class="cardHint" id="chartHint">タップで数値表示</div>
    </div>

    <div class="chipRow" id="chipRow">
      <button class="chip active" data-mode="hour">時間別</button>
      <button class="chip" data-mode="dow">曜日別</button>
      <button class="chip" data-mode="day">日別</button>
    </div>

    <div class="chartArea" id="chart">
      <div class="cursorLine" id="cursorLine"></div>
      <div class="tooltip" id="tooltip">
        <span class="sub" id="tipLabel">—</span>
        <b id="tipValue">—</b>
      </div>
      <div class="yLabels" id="yLabels"></div>

      <svg viewBox="0 0 360 220" preserveAspectRatio="none" id="svg">
        <g id="grid"></g>
        <path id="fill" class="pathFill"></path>
        <path id="line" class="pathStroke"></path>
        <g id="points"></g>
      </svg>
    </div>

    <div class="xLabels" id="xLabels"></div>

    <div class="monthRow">
      <div class="monthMeta" id="monthMeta">—</div>
      <div class="monthMeta">（UI試作）</div>
    </div>

    <div class="monthSelect" id="monthSelect"></div>

    <div class="note">
      ※ 数値はサンプル表示です（CSVなどの実データ連携は別途）。<br/>
      ※ 「高い値で吹き出しが切れる」問題は、吹き出し位置を枠内に収める処理で解消しています。
    </div>
  </div>

</div>

<script>
  const el = (id)=>document.getElementById(id);

  // ---- sample data ----
  const months = [
    { key:"2025-09", label:"2025年9月", rev: 122000, cnt: 320, users: 140,
      hour:[0,0,0,0,0,0,0,0,0,1000,6800,12740,8900,8600,8493,3430,9100,10200,10000,8600,6200,3000,0,0],
      dow :[9800,12000,14200,12800,13600,7800,12647],
      day : Array.from({length:30},(_,i)=> (i<3? 0 : (i<10? (3000+ i*400) : (i<18? (6000 + (i%3)*1800) : (i<25? (4200 + (i%4)*1200) : (2000 + (i%3)*700)))))
    },
    { key:"2025-10", label:"2025年10月", rev: 69000, cnt: 257, users: 118,
      hour:[0,0,0,0,0,0,0,0,0,800,5200,11200,7400,6900,7200,3430,7600,8200,7800,6100,4700,2100,0,0],
      dow :[7600,9800,10800,10200,11000,6900,8600],
      day : Array.from({length:31},(_,i)=> (i<2?0:(i<12? (2400+i*250):(i<20?(5200+(i%3)*1600):(i<26?(3800+(i%4)*1100):(1800+(i%3)*650)))))
    },
    { key:"2025-11", label:"2025年11月", rev: 91000, cnt: 288, users: 132,
      hour:[0,0,0,0,0,0,0,0,0,900,6100,11800,8100,7900,8400,3430,8800,9900,9300,7800,5200,2500,0,0],
      dow :[8400,10500,12000,11600,11900,7200,9800],
      day : Array.from({length:30},(_,i)=> (i<1?0:(i<8?(2600+i*300):(i<18?(5400+(i%3)*1700):(i<24?(4000+(i%4)*1200):(1900+(i%3)*650)))))
    }
  ];

  let currentMonthIndex = 1; // default 2025-10
  let mode = "hour"; // hour / dow / day

  // ---- helpers ----
  const yen = (n)=> "¥ " + (Math.round(n)).toLocaleString("ja-JP");
  const pct = (x)=> (Math.round(x*10)/10).toFixed(1) + "%";

  function getCurrent(){
    return months[currentMonthIndex];
  }

  function buildMonthSelect(){
    const wrap = el("monthSelect");
    wrap.innerHTML = "";
    months.forEach((m, idx)=>{
      const b = document.createElement("button");
      b.className = "monthBtn" + (idx===currentMonthIndex ? " active":"");
      b.textContent = m.label;
      b.addEventListener("click", ()=>{
        currentMonthIndex = idx;
        document.querySelectorAll(".monthBtn").forEach(x=>x.classList.remove("active"));
        b.classList.add("active");
        updateTopKpis();
        renderChart();
      });
      wrap.appendChild(b);
    });
  }

  function updateTopKpis(){
    const cur = getCurrent();
    el("kpiRev").textContent = yen(cur.rev);
    el("kpiCnt").textContent = cur.cnt.toLocaleString("ja-JP");
    el("kpiUsers").textContent = cur.users.toLocaleString("ja-JP");

    const prev = months[currentMonthIndex-1];
    if(prev){
      const mom = (cur.rev / prev.rev) * 100;
      el("kpiMoM").textContent = pct(mom);
    }else{
      el("kpiMoM").textContent = "—";
    }
    el("monthMeta").textContent = `${cur.label} の集計`;
  }

  function setMode(newMode){
    mode = newMode;
    document.querySelectorAll("#chipRow .chip").forEach(btn=>{
      btn.classList.toggle("active", btn.dataset.mode===mode);
    });
    renderChart();
  }

  // ---- chart rendering ----
  const chart = {
    w: 360,
    h: 220,
    padL: 10,
    padR: 42,
    padT: 8,
    padB: 26
  };

  function xLabelsForMode(){
    if(mode==="hour") return ["0時","3時","6時","9時","12時","15時","18時","21時","23時"];
    if(mode==="dow") return ["日","月","火","水","木","金","土"];
    // day
    const cur = getCurrent();
    const days = cur.day.length;
    const labels = [];
    const step = Math.max(1, Math.floor((days-1)/6));
    for(let d=1; d<=days; d+=step){
      labels.push(d+"日");
    }
    if(labels[labels.length-1] !== days+"日") labels.push(days+"日");
    return labels;
  }

  function dataForMode(){
    const cur = getCurrent();
    if(mode==="hour"){
      const d = cur.hour;
      return {
        labels: Array.from({length:24},(_,i)=> i+"時"),
        values: d,
        xCount: 24
      };
    }
    if(mode==="dow"){
      const d = cur.dow;
      return {
        labels: ["日","月","火","水","木","金","土"],
        values: d,
        xCount: 7
      };
    }
    const d = cur.day;
    return {
      labels: Array.from({length:d.length},(_,i)=> (i+1)+"日"),
      values: d,
      xCount: d.length
    };
  }

  function niceTicks(max, min=0){
    const span = max-min;
    if(span<=0) return [min, min, min];
    const rough = span/2;
    const pow = Math.pow(10, Math.floor(Math.log10(rough)));
    const step = Math.ceil(rough/pow) * pow;
    const top = Math.ceil(max/step)*step;
    const mid = top - step;
    const bot = Math.max(0, mid - step);
    return [top, mid, bot];
  }

  function scaleY(val, maxVal){
    const {padT,padB,h} = chart;
    const innerH = h - padT - padB;
    const y = padT + (1 - (val/maxVal)) * innerH;
    return y;
  }
  function scaleX(idx, count){
    const {padL,padR,w} = chart;
    const innerW = w - padL - padR;
    if(count<=1) return padL + innerW/2;
    return padL + (idx/(count-1)) * innerW;
  }

  function renderAxesTicks(ticks){
    const yLabels = el("yLabels");
    yLabels.innerHTML = "";
    ticks.forEach(t=>{
      const d = document.createElement("div");
      d.textContent = Math.round(t).toLocaleString("ja-JP");
      yLabels.appendChild(d);
    });

    const grid = el("grid");
    grid.innerHTML = "";
    const ys = ticks.map(t => scaleY(t, ticks[0] || 1));
    ys.forEach(y=>{
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", chart.padL);
      ln.setAttribute("x2", chart.w - chart.padR);
      ln.setAttribute("y1", y);
      ln.setAttribute("y2", y);
      ln.setAttribute("class","gridLine");
      grid.appendChild(ln);
    });
  }

  function renderXLabels(){
    const xWrap = el("xLabels");
    xWrap.innerHTML = "";
    if(mode==="hour"){
      const labels = ["0時","3時","6時","9時","12時","15時","18時","21時","23時"];
      labels.forEach(l=>{
        const s = document.createElement("span");
        s.textContent = l;
        xWrap.appendChild(s);
      });
      return;
    }
    if(mode==="dow"){
      ["日","月","火","水","木","金","土"].forEach(l=>{
        const s = document.createElement("span");
        s.textContent = l;
        xWrap.appendChild(s);
      });
      return;
    }
    // day
    const cur = getCurrent();
    const days = cur.day.length;
    const labelIdxs = [1, Math.ceil(days*0.2), Math.ceil(days*0.4), Math.ceil(days*0.6), Math.ceil(days*0.8), days];
    const uniq = Array.from(new Set(labelIdxs)).sort((a,b)=>a-b);
    uniq.forEach(d=>{
      const s = document.createElement("span");
      s.textContent = d+"日";
      xWrap.appendChild(s);
    });
  }

  function pathFromPoints(points){
    if(points.length===0) return "";
    const d = [];
    d.push(`M ${points[0].x} ${points[0].y}`);
    for(let i=1;i<points.length;i++){
      d.push(`L ${points[i].x} ${points[i].y}`);
    }
    return d.join(" ");
  }

  function fillPathFromPoints(points){
    if(points.length===0) return "";
    const {padB,h,padT} = chart;
    const baseY = h - padB;
    const d = [];
    d.push(`M ${points[0].x} ${baseY}`);
    d.push(`L ${points[0].x} ${points[0].y}`);
    for(let i=1;i<points.length;i++){
      d.push(`L ${points[i].x} ${points[i].y}`);
    }
    d.push(`L ${points[points.length-1].x} ${baseY}`);
    d.push("Z");
    return d.join(" ");
  }

  function renderChart(){
    const {labels, values, xCount} = dataForMode();

    const maxVal = Math.max(1, ...values);
    const ticks = niceTicks(maxVal, 0);

    renderAxesTicks(ticks);
    renderXLabels();

    // convert to points
    const pts = values.map((v,i)=>({
      x: scaleX(i, xCount),
      y: scaleY(v, ticks[0] || 1),
      v,
      label: labels[i]
    }));

    el("line").setAttribute("d", pathFromPoints(pts));
    el("fill").setAttribute("d", fillPathFromPoints(pts));

    const pWrap = el("points");
    pWrap.innerHTML = "";
    pts.forEach(p=>{
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", p.x);
      c.setAttribute("cy", p.y);
      c.setAttribute("r", 4.6);
      c.setAttribute("class","point");
      pWrap.appendChild(c);
    });

    // attach interaction
    const area = el("chart");
    const svg = el("svg");
    const tooltip = el("tooltip");
    const cursorLine = el("cursorLine");

    function hideTip(){
      tooltip.style.display = "none";
      cursorLine.style.display = "none";
    }

    function getLocalPos(ev){
      const rect = area.getBoundingClientRect();
      const x = (ev.clientX - rect.left);
      const y = (ev.clientY - rect.top);
      return {x,y, rect};
    }

    function nearestPoint(px){
      // map px (in CSS pixels) to svg units since viewBox fixed
      const rect = area.getBoundingClientRect();
      const scaleXpx = chart.w / rect.width;
      const scaleYpx = chart.h / rect.height;
      const xSvg = px * scaleXpx;

      let best = 0, bestDist = Infinity;
      for(let i=0;i<pts.length;i++){
        const dx = pts[i].x - xSvg;
        const dist = Math.abs(dx);
        if(dist < bestDist){
          bestDist = dist; best = i;
        }
      }
      return best;
    }

    function renderTooltipAtPoint(pIndex, clientX, clientY){
      const rect = area.getBoundingClientRect();
      const scaleXpx = rect.width / chart.w;
      const scaleYpx = rect.height / chart.h;

      const p = pts[pIndex];
      const x = p.x * scaleXpx;
      const y = p.y * scaleYpx;

      renderTooltip(x, y, p.label, p.v);
    }

    // iOS/Android: pointer events
    function onMove(ev){
      const p = getLocalPos(ev);
      const idx = nearestPoint(p.x);
      renderTooltipAtPoint(idx, ev.clientX, ev.clientY);
    }

    area.onpointerdown = (ev)=>{ area.setPointerCapture(ev.pointerId); onMove(ev); };
    area.onpointermove = (ev)=>{ if(ev.pressure>0 || ev.buttons===1) onMove(ev); };
    area.onpointerup = ()=>{};
    area.onpointerleave = ()=>{ hideTip(); };

    // also show on tap/click
    area.addEventListener("click",(ev)=>{ onMove(ev); });

    // default show nothing
    hideTip();
  }

  function renderTooltip(x, y, label, val){
    const line = el("cursorLine");
    const tip = el("tooltip");
    line.style.display = "block";
    tip.style.display = "block";
    line.style.left = x + "px";

    el("tipLabel").textContent = label;
    el("tipValue").textContent = yen(val);

    // 高い数値でも表示が切れないように、画面内に収まる位置へ固定する
    tip.style.transform = "none";

    const margin = 8;
    const gap = 10;

    const tipW = tip.offsetWidth;
    const tipH = tip.offsetHeight;

    let left = x - tipW/2;
    if(left < margin) left = margin;
    if(left > chart.w - tipW - margin) left = chart.w - tipW - margin;

    // 基本は「点の上」。上に出せないときは「点の下」に回す
    let top = y - tipH - gap;
    if(top < margin) top = y + gap;

    // それでもはみ出す場合は、最終的に画面内へ収める
    if(top > chart.h - tipH - margin) top = chart.h - tipH - margin;
    if(top < margin) top = margin;

    tip.style.left = left + "px";
    tip.style.top = top + "px";
  }

  // init
  buildMonthSelect();
  updateTopKpis();
  renderChart();

  // chips events
  document.querySelectorAll("#chipRow .chip").forEach(btn=>{
    btn.addEventListener("click", ()=> setMode(btn.dataset.mode));
  });
</script>

</body>
</html>
