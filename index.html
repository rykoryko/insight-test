<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Pixy インサイト</title>
  <style>html{ -webkit-text-size-adjust: 100%; }

    :root{
      --bg:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --line:#f3a6c8;
      --chip:#e5e7eb;
      --chipText:#111827;
      --chipActive:#111111;
      --chipActiveText:#ffffff;
      --card:#ffffff;
      --cardBorder:#d1d5db;
      --cardActiveBg:#fde7ef;
      --cardActiveBorder:#f3a6c8;
      --shadow: 0 8px 20px rgba(0,0,0,.08);
      --radius: 14px;
      --blue:#2563eb;
      --pink:#ff4db8;
      --grid:#e5e7eb;
      --danger:#ff4d4f;
    }
    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Meiryo", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    a{color:inherit;}
    .wrap{ max-width: 420px; margin:0 auto; padding: 10px 12px 28px; }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding: 4px 2px 8px; position: sticky; top: 0; background: var(--bg); z-index: 30;
    }
    .logo{ font-weight:700; letter-spacing:.02em; font-size: 18px; }
    .title{ font-size: 18px; font-weight:700; text-align:center; flex:1; }
    .spacer{width:48px;}
    .pinkline{ height:2px; background: var(--line); border-radius:999px; margin: 0 0 10px; opacity:.75; }
    .label{ font-size: 13px; color: var(--text); margin: 6px 0 6px; font-weight:600; }
    .input{
      width:100%; border:0; border-bottom:2px solid var(--line);
      padding:10px 2px 10px; font-size:16px; outline:none; background:transparent;
    }

    .chipRow{
      display:flex; gap:8px; overflow:auto; padding:10px 0 2px;
      -webkit-overflow-scrolling: touch; scrollbar-width: none;
    }
    .chipRow::-webkit-scrollbar{ display:none; }
    .chip{
      border:0; padding:8px 14px; border-radius:999px;
      background:var(--chip); color:var(--chipText);
      font-weight:700; font-size:13px; cursor:pointer; white-space:nowrap;
      flex:0 0 auto; transition: transform .08s ease;
    }
    .chip:active{ transform: scale(.98); }
    .chip.active{ background:var(--chipActive); color:var(--chipActiveText); }

    .sectionTitle{ display:flex; align-items:flex-end; justify-content:space-between; gap:10px; margin-top: 10px; }
    .sectionTitle h2{ margin:0; font-size: 18px; font-weight:800; letter-spacing:.01em; }
    .divider{ height:2px; background: var(--line); border-radius:999px; margin: 6px 0 10px; opacity:.75; }

    .cards{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .card{
      border: 1.5px solid var(--cardBorder); background: var(--card);
      border-radius: 12px; padding: 10px; cursor:pointer;
      transition: transform .08s ease, border-color .15s ease, background .15s ease;
      min-height: 88px; position:relative;
    }
    .card:active{ transform: scale(.99); }
    .card.active{ border-color: var(--cardActiveBorder); background: var(--cardActiveBg); }
    .card .kpiTitle{ font-size: 12px; color: var(--muted); font-weight:700; margin-bottom: 6px; }
    .card .kpiValue{ font-size: 20px; font-weight:900; margin-bottom: 2px; }
    .card .kpiSub{ font-size: 12px; color: var(--muted); font-weight:700; }

    .miniGrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 6px 10px; margin-top: 6px; align-items:end; }
    .miniItem .miniLabel{ font-size: 10px; color: var(--muted); font-weight:700; line-height:1.1; }
    .miniItem .miniVal{ font-size: 16px; font-weight:900; margin-top:2px; line-height:1.1; }

    .toggleRow{ display:flex; gap:8px; margin: 10px 0 8px; }
    .toggle{
      border:0; background: var(--chip); color: var(--chipText);
      font-weight:800; font-size: 13px; padding:8px 12px; border-radius: 999px;
      cursor:pointer; transition: transform .08s ease;
    }
    .toggle:active{ transform: scale(.98); }
    .toggle.active{ background: #4b5563; color:#fff; }

    .chartCard{
      border-radius: var(--radius); background:#fff; box-shadow: var(--shadow);
      padding: 10px 10px 8px; position:relative; overflow:hidden;
    }
    .chartCard *{ font-size: 14px; } /* フォントサイズ統一 */
    .chartWrap{ position:relative; height: 180px; margin-top: 4px; border-radius: 12px; background: #ffffff; overflow:hidden; }

    .chartViewport{
      touch-action: pan-y;
      position:absolute; left:0; right:0; top:0; bottom:28px;
      overflow-x:hidden; overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
    }
    .chartInner{ position:relative; height:100%; width: 100%; }
    canvas{display:block; width:100%; height:100%;}

    .yLabels{
      position:absolute; right: 6px; top: 4px; bottom: 28px;
      display:flex; flex-direction:column; justify-content:space-between;
      pointer-events:none; font-size: 11px; color: var(--muted); font-weight:700; opacity:.9;
      z-index: 5;
      background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.92) 25%, rgba(255,255,255,1) 60%);
      padding-left: 16px;
    }

    .cursorLine{
      position:absolute; top: 8px; bottom: 8px; width:2px;
      background: rgba(37,99,235,.55); border-radius:999px;
      pointer-events:none; display:none; z-index: 3;
    }
    .tooltip{
      position:absolute; min-width: 90px; padding: 8px 10px;
      background:#fff; border:1px solid rgba(0,0,0,.08); box-shadow: 0 10px 30px rgba(0,0,0,.12);
      border-radius: 10px; font-size: 12px; font-weight:800; color: var(--text);
      transform: translateX(-50%); pointer-events:none; display:none; white-space:nowrap; z-index: 8; /* 修正: 右の目盛りより前に出す */
    }
    .tooltip .tLabel{ font-size: 12px; font-weight:900; margin-bottom: 2px; color: var(--text); }
    .tooltip .tVal{ font-size:18px; font-weight:900; color: var(--muted); }

    .xLabelsViewport{ margin-top: 8px; overflow-x:hidden; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
    .xLabelsViewport::-webkit-scrollbar{ display:none; }
    .xLabels{
      display:flex; gap:0; user-select:none; font-size: 12px; color: var(--muted);
      font-weight:700; padding: 0 2px; white-space:nowrap;
    }
    .xLabels span{
      flex: 0 0 var(--slot, 64px); text-align:center; overflow:visible; text-overflow:clip;
    }

    .detailTabs{ display:flex; gap:8px; margin: 10px 0 10px; }
    .tab{ border:0; padding: 8px 14px; border-radius: 999px; background: var(--chip); color: var(--chipText); font-weight:900; font-size: 13px; cursor:pointer; }
    .tab.active{ background:#4b5563; color:#fff; }

    .panel{ background:#fff; border-radius: var(--radius); box-shadow: var(--shadow); padding: 12px; }
    .panel + .panel{ margin-top: 10px; }

    .subSection{ margin-top: 6px; font-size: 13px; font-weight:900; color: var(--text); display:flex; align-items:center; gap:8px; }
    .dot{ width:10px; height:10px; border-radius:2px; background: var(--blue); flex:0 0 auto; }

    .rows{ margin-top: 8px; border-top:1px solid rgba(0,0,0,.06); }
    .row{
      display:flex; justify-content:space-between; align-items:center;
      padding: 8px 0; border-bottom:1px solid rgba(0,0,0,.06);
      font-size: 13px; font-weight:700; color: var(--text);
    }
    .row .rVal{ color: var(--text); font-weight:900; }

    .barItem{ margin-top: 10px; }
    .barTop{ display:flex; justify-content:space-between; gap:8px; font-size: 12px; font-weight:800; color: var(--text); }
    .barBg{ height: 10px; background: #e5e7eb; border-radius: 999px; overflow:hidden; margin-top: 6px; }
    .barFill{ height: 100%; background: var(--blue); width: 0%; border-radius: 999px; }

    .genderBar{ margin-top: 10px; }
    .genderTrack{ height: 10px; background: #e5e7eb; border-radius: 999px; overflow:hidden; display:flex; }
    .genderFemale{ background: var(--pink); }
    .genderMale{ background: var(--blue); }
    .genderLabels{ margin-top: 8px; display:flex; justify-content:space-between; font-size: 12px; color: var(--text); font-weight:800; }
    .muted{ color: var(--muted); font-weight:700; }

    .p2Box{ background:#fff; border-radius: var(--radius); box-shadow: var(--shadow); padding: 12px; margin-top: 10px; }
    .p2Title{ font-size: 13px; font-weight: 900; margin: 0 0 10px; }
    .p2TableHeader{
      display:grid; grid-template-columns: 64px 1fr 56px 56px; gap: 8px;
      font-size: 11px; color: var(--muted); font-weight: 900;
      padding-bottom: 6px; border-bottom: 1px solid rgba(0,0,0,.06);
    }
    .p2Row{
      display:grid; grid-template-columns: 64px 1fr 56px 56px; gap: 8px;
      align-items:center; padding: 8px 0; border-bottom: 1px solid rgba(0,0,0,.06);
      font-size: 12px; font-weight: 800;
    }
    .p2BarBg{ height: 8px; background:#e5e7eb; border-radius:999px; overflow:hidden; }
    .p2BarFill{ height: 100%; background: var(--blue); width: 0%; border-radius:999px; }

    .ctaRow{ display:flex; justify-content:flex-end; margin-top: 12px; }
    .cta{
      display:inline-flex; align-items:center; justify-content:center; border:0;
      padding: 10px 18px; border-radius: 999px; background: var(--danger); color:#fff;
      font-weight: 900; font-size: 14px; text-decoration:none; min-width: 140px;
      box-shadow: 0 10px 18px rgba(255,77,79,.25); transition: transform .08s ease;
    }
    .cta:active{ transform: scale(.99); }
    .hidden{ display:none !important; }

    @media (max-width: 420px){
      .xLabels span{font-size:11px;}
      .tooltip{min-width:94px;}
      .tooltip .tVal{font-size:16px;}
    }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="logo">Pixy</div>
      <div class="title">インサイト</div>
      <div class="spacer"></div>
    </div>
    <div class="pinkline"></div>

    <div class="label">鑑定師名</div>
    <input id="readerName" class="input" placeholder="例：minami" list="nameList" value="minami" />
    <datalist id="nameList">
      <option value="minami"></option>
    </datalist>

    <div class="chipRow" id="monthRow" aria-label="月選択"></div>

    <div class="sectionTitle">
      <h2>メインデータ</h2>
    </div>
    <div class="divider"></div>

    <div class="cards" role="tablist" aria-label="メイン切替">
      <button class="card active" id="tabKpi" role="tab" aria-selected="true">
        <div class="kpiTitle">今月の報酬金</div>
        <div class="kpiValue" id="kpiMoney">—</div>
        <div class="kpiSub">前月比　<span id="kpiMoM">—</span></div>
      </button>
      <button class="card" id="tabDetail" role="tab" aria-selected="false">
        <div class="kpiTitle">鑑定データ詳細</div>
        <div class="miniGrid">
          <div class="miniItem">
            <div class="miniLabel">リピート件数</div>
            <div class="miniVal" id="kpiRepeatCnt">—</div>
          </div>
          <div class="miniItem" style="text-align:right">
            <div class="miniLabel">リピート人数</div>
            <div class="miniVal" id="kpiRepeatUsers">—</div>
          </div>
          <div class="miniItem">
            <div class="miniLabel">鑑定件数</div>
            <div class="miniVal" id="kpiKanteiCnt">—</div>
          </div>
          <div class="miniItem" style="text-align:right">
            <div class="miniLabel">鑑定人数</div>
            <div class="miniVal" id="kpiKanteiUsers">—</div>
          </div>
        </div>
      </button>
    </div>

    <div id="viewKpi">
      <div class="toggleRow" aria-label="グラフ切替">
        <button class="toggle active" data-mode="hour">時間別</button>
        <button class="toggle" data-mode="weekday">曜日別</button>
        <button class="toggle" data-mode="day">日別</button>
      </div>

      <div class="chartCard">
        <div class="chartWrap">
          <div class="chartViewport" id="chartViewport">
            <div class="chartInner" id="chartInner">
              <canvas id="chart"></canvas>
              <div class="cursorLine" id="cursorLine"></div>
              <div class="tooltip" id="tooltip">
                <div class="tLabel" id="tipLabel">—</div>
                <div class="tVal" id="tipValue">—</div>
              </div>
            </div>
          </div>

          <div class="yLabels">
            <div id="yTop">—</div>
            <div id="yMid">—</div>
            <div id="yBot">—</div>
          </div>
        </div>

        <div class="xLabelsViewport" id="xLabelsViewport">
          <div class="xLabels" id="xLabels"></div>
        </div>
      </div>

      <div class="sectionTitle" style="margin-top:14px;">
        <h2>詳細データ</h2>
      </div>
      <div class="divider"></div>

      <div class="detailTabs">
        <button class="tab active" data-detail="user">ユーザー分析</button>
        <button class="tab" data-detail="reader">鑑定師分析</button>
      </div>

      <div id="panelUser" class="panel">
        <div class="subSection"><span class="dot"></span>年齢構成比</div>
        <div id="ageList"></div>

        <div class="subSection" style="margin-top:14px;"><span class="dot"></span>男女比率</div>
        <div class="genderBar">
          <div class="genderTrack">
            <div class="genderFemale" id="femaleBar" style="width:0%"></div>
            <div class="genderMale" id="maleBar" style="width:0%"></div>
          </div>
          <div class="genderLabels">
            <div>女性　<span class="muted" id="femalePct">—</span></div>
            <div>男性　<span class="muted" id="malePct">—</span></div>
          </div>
        </div>
      </div>

      <div id="panelReader" class="panel hidden">
        <div class="subSection"><span class="dot"></span>待機時間</div>
        <div class="rows">
          <div class="row"><div class="rLabel">今月の待機時間</div><div class="rVal" id="waitThis">—</div></div>
          <div class="row"><div class="rLabel">前月の待機時間</div><div class="rVal" id="waitPrev">—</div></div>
          <div class="row"><div class="rLabel">前月比</div><div class="rVal" id="waitMoM">—</div></div>
        </div>

        <div class="subSection" style="margin-top:12px;"><span class="dot" style="background:#22c55e"></span>アフターメッセージ</div>
        <div class="rows">
          <div class="row"><div class="rLabel">鑑定件数</div><div class="rVal" id="amTotal">—</div></div>
          <div class="row"><div class="rLabel">送信数</div><div class="rVal" id="amSent">—</div></div>
          <div class="row"><div class="rLabel">未送信</div><div class="rVal" id="amUnsent">—</div></div>
          <div class="row"><div class="rLabel">送信率</div><div class="rVal" id="amRate">—</div></div>
        </div>
      </div>
    </div>

    <div id="viewDetail" class="hidden">
      <div class="p2Box">
        <div class="p2Title">回数別ユーザー数</div>
        <div class="p2TableHeader">
          <div>区分</div>
          <div></div>
          <div style="text-align:right;">人数</div>
          <div style="text-align:right;">割合</div>
        </div>
        <div id="p2Rows"></div>

        <div class="ctaRow">
          <a class="cta" href="https://kuboizaizen.github.io/shino-insight/" target="_blank" rel="noopener noreferrer">詳細を確認</a>
        </div>
      </div>
    </div>

    <div style="height:12px"></div>
  </div>

<script>
  const el = (id) => document.getElementById(id);

  function yen(n){
    if(n==null || isNaN(n)) return "—";
    return "¥ " + Math.round(n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  function pctText(n){
    if(n==null || isNaN(n)) return "—";
    const v = Math.round(n*10)/10;
    return v.toString().replace(/\.0$/,"") + "%";
  }
  function hoursText(n){
    if(n==null || isNaN(n)) return "—";
    const v = Math.round(n*10)/10;
    return v.toString().replace(/\.0$/,"");
  }

  // ===== 修正: グラフの点数をモードごとに正規化（時間=24 / 曜日=7 / 日=31） =====
  // もともとのデータが「0時,3時,6時...」のように間引かれていても、
  // ここで「存在しない点は0」として埋めて、1つずつ確認できるようにします。
  const _chartNormCache = {};
  function getNormalizedChartData(month, mode){
    const key = month + "|" + mode;
    if(_chartNormCache[key]) return _chartNormCache[key];

    const raw = (APP.dataByMonth && APP.dataByMonth[month] && APP.dataByMonth[month].chart && APP.dataByMonth[month].chart[mode])
      ? APP.dataByMonth[month].chart[mode]
      : {labels:[], values:[]};

    const rawLabels = raw.labels || [];
    const rawValues = raw.values || [];

    let labels = [];
    let values = [];
    let ticks = []; // x軸に「表示する文字」（空文字なら表示しない）

    if(mode === "hour"){
      labels = Array.from({length:24}, (_,i)=> `${i}時`);
      values = Array.from({length:24}, ()=> 0);
      // raw: ["0時","3時",...,"23時"] を 0〜23 に埋める
      for(let i=0;i<rawLabels.length;i++){
        const h = parseInt(rawLabels[i], 10);
        if(!isNaN(h) && h>=0 && h<=23) values[h] = Number(rawValues[i] ?? 0) || 0;
      }
      // 画面表示は読みやすさ優先で「3時間ごと＋最後(23時)」だけ出す
      ticks = labels.map((lab, i)=> (i%3===0 || i===23) ? lab : "");
    }else if(mode === "weekday"){
      labels = ["日","月","火","水","木","金","土"];
      values = Array.from({length:7}, ()=> 0);
      const map = {"日":0,"月":1,"火":2,"水":3,"木":4,"金":5,"土":6};
      for(let i=0;i<rawLabels.length;i++){
        const k = rawLabels[i];
        const idx = map[k];
        if(idx!=null) values[idx] = Number(rawValues[i] ?? 0) || 0;
      }
      ticks = labels.slice(); // 全部表示
    }else{ // "day"
      labels = Array.from({length:31}, (_,i)=> `${i+1}日`);
      values = Array.from({length:31}, ()=> 0);
      for(let i=0;i<rawLabels.length;i++){
        const day = parseInt(rawLabels[i], 10);
        if(!isNaN(day) && day>=1 && day<=31) values[day-1] = Number(rawValues[i] ?? 0) || 0;
      }
      // 画面表示は「1,6,11,16,21,26,31」だけ（既存の見た目に合わせる）
      const show = new Set([1,6,11,16,21,26,31]);
      ticks = labels.map((lab, i)=> show.has(i+1) ? lab : "");
    }

    const out = {labels, values, ticks};
    _chartNormCache[key] = out;
    return out;
  }
  // ===== 修正ここまで =====


  // === 外部JSON読み込み（insight_data.json） ===
  const APP = {
    months: [],
    state: {
      month: "",
      mainTab: "kpi",
      chartMode: "hour",   // hour / weekday / day
      detailTab: "user",   // user / reader
      cursorIndex: null
    },
    dataByMonth: {},
    kanteishiList: [],
    selectedKanteishiId: null,
    loaded: false
  };

  function monthLabel(ym){
    // "2025-12" -> "12月"
    if(!ym) return "";
    const parts = String(ym).split("-");
    const m = parts.length >= 2 ? parseInt(parts[1], 10) : NaN;
    if(!Number.isFinite(m)) return String(ym);
    return String(m) + "月";
  }
  function parsePctText(s){
    if(s == null) return null;
    const t = String(s).trim().replace("%","");
    const n = Number(t);
    return Number.isFinite(n) ? n : null;
  }
  function clearChartCache(){
    // _chartNormCache は const なので中身だけ消す
    try{
      for(const k in _chartNormCache) delete _chartNormCache[k];
    }catch(_){}
  }

  function buildDataByMonthFromKanteishi(k){
    const monthsYM = Object.keys(k?.months || {}).sort((a,b)=> b.localeCompare(a));
    APP.months = monthsYM.map(monthLabel);

    const out = {};
    monthsYM.forEach(ym=>{
      const lab = monthLabel(ym);
      const mo = k.months?.[ym] || {};

      const rep = mo.repeat || {};
      const kan = mo.kantei || {};

      const p2Counts = (mo.counts_by_times || []).map(it=>({
        label: it.label,
        n: it.users,
        pct: it.pct
      }));

      const hourVals = Array.isArray(mo.reward_by_hour) ? mo.reward_by_hour.map(v=> Number(v) || 0) : [];
      const wdayVals = Array.isArray(mo.reward_by_weekday) ? mo.reward_by_weekday.map(v=> Number(v) || 0) : [];

      out[lab] = {
        money: mo.reward ?? null,
        mom: parsePctText(mo.prev_ratio),
        repeatCnt: rep.count ?? null,
        repeatUsers: rep.users ?? null,
        kanteiCnt: kan.count ?? null,
        kanteiUsers: kan.users ?? null,

        // 回数別
        p2: { counts: p2Counts },

        // グラフ（時間別/曜日別/日別）
        chart: {
          hour:   { labels: hourVals.map((_,i)=> String(i)), values: hourVals },
          weekday:{ labels: ["日","月","火","水","木","金","土"], values: wdayVals },
          day:    { labels: [], values: [] } // いまJSONに日別がないので空にしておく
        },

        // いまのJSONには未収録（後で入れる想定）
        user: mo.user ?? { age: [], gender: { female: null, male: null } },
        reader: mo.reader ?? {}
      };
    });

    APP.dataByMonth = out;

    if(APP.months.length){
      // 既存の選択を維持。なければ先頭（最新）へ
      if(!APP.state.month || !APP.dataByMonth[APP.state.month]){
        APP.state.month = APP.months[0];
      }
    }else{
      APP.state.month = "";
    }
  }

  function populateKanteishiUI(){
    const input = el("readerName");
    const list = el("nameList");
    if(list){
      list.innerHTML = "";
      (APP.kanteishiList || []).forEach(k=>{
        const opt = document.createElement("option");
        opt.value = k.name;
        list.appendChild(opt);
      });
    }
    if(input && !input.value && APP.kanteishiList?.[0]){
      input.value = APP.kanteishiList[0].name;
    }
  }

  function selectKanteishiByName(name){
    const list = APP.kanteishiList || [];
    const k = list.find(x=> x.name === name) || list[0];
    if(!k) return;

    APP.selectedKanteishiId = k.id;
    buildDataByMonthFromKanteishi(k);

    initMonths();
    clearChartCache();
    syncAll(true);
  }

  async function loadInsightData(){
    try{
      const res = await fetch("./insight_data.json?ts=" + Date.now(), { cache: "no-store" });
      if(!res.ok) throw new Error("HTTP " + res.status);
      const json = await res.json();

      APP.kanteishiList = Array.isArray(json.kanteishi) ? json.kanteishi : [];
      populateKanteishiUI();

      // 初期選択
      const name = el("readerName")?.value || "";
      selectKanteishiByName(name);

      APP.loaded = true;
    }catch(err){
      console.error("insight_data.json の読み込みに失敗:", err);
      APP.loaded = false;
      APP.kanteishiList = [];
      APP.selectedKanteishiId = null;
      APP.months = [];
      APP.dataByMonth = {};
      APP.state.month = "";
      initMonths();
      syncAll(true);
    }
  }



  function initMonths(){
    const row = el("monthRow"); row.innerHTML = "";
    APP.months.forEach(m=>{
      const b = document.createElement("button");
      b.className = "chip" + (m===APP.state.month ? " active":"");
      b.textContent = m;
      b.addEventListener("click", ()=>{ APP.state.month=m; syncAll(true); });
      row.appendChild(b);
    });
  }

  function syncKPIs(){
    const d = APP.dataByMonth[APP.state.month] || {};
    el("kpiMoney").textContent = yen(d.money);
    el("kpiMoM").textContent = (d.mom==null ? "—" : pctText(d.mom));
    el("kpiRepeatCnt").textContent = (d.repeatCnt==null ? "—" : d.repeatCnt);
    el("kpiRepeatUsers").textContent = (d.repeatUsers==null ? "—" : d.repeatUsers);
    el("kpiKanteiCnt").textContent = (d.kanteiCnt==null ? "—" : d.kanteiCnt);
    el("kpiKanteiUsers").textContent = (d.kanteiUsers==null ? "—" : d.kanteiUsers);
  }

  function syncMonthChips(){
    [...document.querySelectorAll("#monthRow .chip")].forEach(ch=>{
      ch.classList.toggle("active", ch.textContent===APP.state.month);
    });
  }

  function syncMainTab(){
    const isKpi = APP.state.mainTab==="kpi";
    el("viewKpi").classList.toggle("hidden", !isKpi);
    el("viewDetail").classList.toggle("hidden", isKpi);
    el("tabKpi").classList.toggle("active", isKpi);
    el("tabKpi").setAttribute("aria-selected", isKpi ? "true":"false");
    el("tabDetail").classList.toggle("active", !isKpi);
    el("tabDetail").setAttribute("aria-selected", !isKpi ? "true":"false");
  }

  function syncDetailTab(){
    const isUser = APP.state.detailTab==="user";
    el("panelUser").classList.toggle("hidden", !isUser);
    el("panelReader").classList.toggle("hidden", isUser);
    [...document.querySelectorAll(".tab")].forEach(t=>{
      t.classList.toggle("active", t.dataset.detail===APP.state.detailTab);
    });
  }

  function syncUserPanel(){
    const d = (APP.dataByMonth[APP.state.month] && APP.dataByMonth[APP.state.month].user) ? APP.dataByMonth[APP.state.month].user : { age: [], gender: { female: null, male: null } };
    const ageWrap = el("ageList"); ageWrap.innerHTML = "";
    (d.age||[]).forEach(item=>{
      const block = document.createElement("div");
      block.className = "barItem";
      block.innerHTML = `
        <div class="barTop"><div>${item.label}</div><div class="pct">${pctText(item.pct)}</div></div>
        <div class="barBg"><div class="barFill" style="width:${Math.max(0,Math.min(100,item.pct))}%"></div></div>
      `;
      ageWrap.appendChild(block);
    });

    const f = (d.gender?.female ?? null);
    const m = (d.gender?.male ?? null);
    el("femaleBar").style.width = (f==null?0:f) + "%";
    el("maleBar").style.width = (m==null?0:m) + "%";
    el("femalePct").textContent = (f==null ? "—" : pctText(f));
    el("malePct").textContent = (m==null ? "—" : pctText(m));
  }

  function syncReaderPanel(){
    const d = (APP.dataByMonth[APP.state.month] && APP.dataByMonth[APP.state.month].reader) ? APP.dataByMonth[APP.state.month].reader : {};

    el("waitThis").textContent = (d.waitThis==null ? "—" : hoursText(d.waitThis) + "h");
    el("waitPrev").textContent = (d.waitPrev==null ? "—" : hoursText(d.waitPrev) + "h");
    el("waitMoM").textContent = (d.waitMoM==null ? "—" : pctText(d.waitMoM));

    const a = d.after || {};
    el("amTotal").textContent = (a.total==null ? "—" : a.total);
    el("amSent").textContent = (a.sent==null ? "—" : a.sent);
    el("amUnsent").textContent = (a.unsent==null ? "—" : a.unsent);
    el("amRate").textContent = (a.rate==null ? "—" : pctText(a.rate));
  }

  function syncP2(){
    const d = (APP.dataByMonth[APP.state.month] && APP.dataByMonth[APP.state.month].p2) ? APP.dataByMonth[APP.state.month].p2 : { counts: [] };
    const rows = el("p2Rows"); rows.innerHTML = "";
    (d.counts||[]).forEach(item=>{
      const r = document.createElement("div");
      r.className = "p2Row";
      r.innerHTML = `
        <div>${item.label}</div>
        <div class="p2BarBg"><div class="p2BarFill" style="width:${Math.max(0,Math.min(100,item.pct))}%"></div></div>
        <div style="text-align:right;">${item.n}人</div>
        <div style="text-align:right;">${pctText(item.pct)}</div>
      `;
      rows.appendChild(r);
    });
  }

  function syncChartModeButtons(){
    [...document.querySelectorAll(".toggle")].forEach(b=>{
      b.classList.toggle("active", b.dataset.mode===APP.state.chartMode);
    });
  }

  const chart = {
    canvas:null, ctx:null, inner:null, viewport:null, xLabelViewport:null, xLabelRow:null,
    w:0, h:0, padding:{ left:10, right:46, top:10, bottom:10 }, yMax:1155, slot:64,
    setSize(){
      const vpRect = this.viewport.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const d = getNormalizedChartData(APP.state.month, APP.state.chartMode);
      const n = d.values.length; // 修正: 正規化後の点数

      const avail = Math.max(1, vpRect.width - this.padding.left - this.padding.right);
      this.slot = Math.max(8, avail / Math.max(1, (n-1)));

      const innerW = vpRect.width;
      const innerH = vpRect.height;

      this.inner.style.width = innerW + "px";
      this.inner.style.height = innerH + "px";

      this.w = Math.floor(innerW);
      this.h = Math.floor(innerH);

      this.canvas.width = Math.floor(this.w * dpr);
      this.canvas.height = Math.floor(this.h * dpr);
      this.canvas.style.width = this.w + "px";
      this.canvas.style.height = this.h + "px";
      this.ctx.setTransform(dpr,0,0,dpr,0,0);

      this.xLabelRow.style.width = innerW + "px";
      this.xLabelRow.style.setProperty("--slot", this.slot + "px");
    },
    draw(){
      const ctx = this.ctx;
      const {w,h,padding} = this;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,w,h);

      const gridYs = [ padding.top + 8, (h + padding.top - padding.bottom)/2, h - padding.bottom - 8 ];
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim() || "#e5e7eb";
      ctx.lineWidth = 1;
      ctx.setLineDash([3,4]);
      gridYs.forEach(y=>{
        ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(w - padding.right, y); ctx.stroke();
      });
      ctx.setLineDash([]);

      const d = getNormalizedChartData(APP.state.month, APP.state.chartMode); // 修正
      const values = d.values;
      const n = values.length;
      if(n===0) return;

      const maxV = Math.max(...values, 1);
      const targetMax = Math.max(1155, Math.ceil(maxV/5)*5);
      this.yMax = targetMax;

      el("yTop").textContent = targetMax.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      el("yMid").textContent = Math.round(targetMax*2/3).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      el("yBot").textContent = Math.round(targetMax*1/3).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

      const x0 = padding.left;
      const y0 = h - padding.bottom;
      const y1 = padding.top;
      const dx = this.slot;

      const pts = values.map((v,i)=>{
        const x = x0 + dx*i;
        const t = v / targetMax;
        const y = y0 - (y0 - y1) * t;
        return {x,y,v,i};
      });

      ctx.beginPath();
      ctx.moveTo(pts[0].x, y0);
      pts.forEach(p=>ctx.lineTo(p.x,p.y));
      ctx.lineTo(pts[pts.length-1].x, y0);
      ctx.closePath();
      ctx.fillStyle = "rgba(37,99,235,.10)";
      ctx.fill();

      ctx.beginPath();
      pts.forEach((p,idx)=>{ if(idx===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--blue").trim() || "#2563eb";
      ctx.lineWidth = 2;
      ctx.stroke();

      const idx = (APP.state.cursorIndex==null ? Math.floor(n/2) : APP.state.cursorIndex);
      const p = pts[Math.max(0,Math.min(n-1,idx))];
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--blue").trim() || "#2563eb";
      ctx.stroke();

      renderXLabels(d.ticks); // 修正: 表示用ラベルは間引き
      renderTooltip(p.x, p.y, d.labels[p.i], p.v);
    }
  };

  function renderXLabels(labels){
    const row = chart.xLabelRow; row.innerHTML = "";
    labels.forEach(lab=>{ const sp = document.createElement("span"); sp.textContent = lab; row.appendChild(sp); });
  }

  // ===== 修正: 吹き出しがスマホで切れないように（左右＋上下の位置を枠内に収める） =====
  function renderTooltip(x, y, label, val){
    const line = el("cursorLine");
    const tip = el("tooltip");
    line.style.display = "block";
    tip.style.display = "block";
    line.style.left = x + "px";

    el("tipLabel").textContent = label;
    el("tipValue").textContent = yen(val);

    // まず仮置き（サイズ測定用）
    tip.style.left = x + "px";
    tip.style.top = y + "px";

    const tipW = tip.offsetWidth;
    const tipH = tip.offsetHeight;

    // 左右のはみ出し防止
    let tipX = x;
    const margin = 8;
    const minX = margin + tipW/2;
    const maxX = chart.w - margin - tipW/2;
    if(tipX < minX) tipX = minX;
    if(tipX > maxX) tipX = maxX;
    tip.style.left = tipX + "px";

    // 上下のはみ出し防止（上が足りないときは下に出す）
    const aboveTop = y - 10 - tipH;
    const belowTop = y + 12;
    let top = aboveTop;
    if(aboveTop < margin) top = belowTop;
    if(top + tipH > chart.h - margin) top = Math.max(margin, chart.h - margin - tipH);
    tip.style.top = top + "px";
  }
  // ===== 修正ここまで =====

  function pickIndexFromClientX(clientX){
    const d = getNormalizedChartData(APP.state.month, APP.state.chartMode); // 修正
    const n = d.values.length;
    const rect = chart.viewport.getBoundingClientRect();
    const xInViewport = clientX - rect.left;
    const x0 = chart.padding.left;
    const dx = chart.slot;
    const i = Math.round((xInViewport - x0) / dx);
    return Math.max(0, Math.min(n-1, i));
  }

  // ===== 修正: 「押したまま左右」でカーソルが1つずつ動くように（スマホ Safari/Chrome 対応） =====
  function attachViewportSelect(){
    const viewport = chart.viewport;

    function selectAtClientX(clientX){
      const idx = pickIndexFromClientX(clientX);
      APP.state.cursorIndex = idx;
      chart.draw();
    }

    // Pointer Events（Chrome等）
    let dragging = false;
    let activePointerId = null;

    viewport.addEventListener("pointerdown",(e)=>{
      dragging = true;
      activePointerId = e.pointerId;
      try{ viewport.setPointerCapture(e.pointerId); }catch(_){}
      selectAtClientX(e.clientX);
    },{passive:true});

    viewport.addEventListener("pointermove",(e)=>{
      if(!dragging) return;
      if(activePointerId!=null && e.pointerId!==activePointerId) return;
      selectAtClientX(e.clientX);
    },{passive:true});

    function endPointer(){
      dragging = false;
      activePointerId = null;
    }
    viewport.addEventListener("pointerup", endPointer, {passive:true});
    viewport.addEventListener("pointercancel", endPointer, {passive:true});

    // Touch Events（iOS Safari 対策）
    let touchStart = null;

    viewport.addEventListener("touchstart",(e)=>{
      if(!e.touches || e.touches.length!==1) return;
      const t = e.touches[0];
      touchStart = {x:t.clientX, y:t.clientY};
      selectAtClientX(t.clientX);
    },{passive:true});

    viewport.addEventListener("touchmove",(e)=>{
      if(!e.touches || e.touches.length!==1) return;
      const t = e.touches[0];

      // 横移動のときだけスクロールを止めて、1つずつ更新
      if(touchStart){
        const dx = t.clientX - touchStart.x;
        const dy = t.clientY - touchStart.y;
        if(Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 6){
          e.preventDefault(); // iOSで「横ドラッグがスクロール扱い」になるのを防ぐ
        }
      }
      selectAtClientX(t.clientX);
    },{passive:false});

    viewport.addEventListener("touchend",()=>{ touchStart = null; },{passive:true});
    viewport.addEventListener("touchcancel",()=>{ touchStart = null; },{passive:true});
  }
  // ===== 修正ここまで =====

  function syncAll(){
    syncMonthChips();
    syncKPIs();
    syncUserPanel();
    syncReaderPanel();
    syncP2();
    syncMainTab();
    syncDetailTab();
    syncChartModeButtons();

    if(APP.state.mainTab==="kpi"){
      chart.setSize();
      chart.draw();
    }
  }

  function attachUIEvents(){
    el("tabKpi").addEventListener("click",()=>{APP.state.mainTab="kpi";syncAll();});
    el("tabDetail").addEventListener("click",()=>{APP.state.mainTab="detail";syncAll();});

    [...document.querySelectorAll(".toggle")].forEach(b=>{
      b.addEventListener("click", ()=>{
        APP.state.chartMode = b.dataset.mode;
        APP.state.cursorIndex = null;
        syncAll();
      });
    });

    [...document.querySelectorAll(".tab")].forEach(b=>{
      b.addEventListener("click", ()=>{
        APP.state.detailTab = b.dataset.detail;
        syncAll();
      });
    });

    window.addEventListener("resize", ()=>{
      if(APP.state.mainTab==="kpi"){
        chart.setSize();
        chart.draw();
      }
    });
  }

  (async function boot(){
    chart.canvas = el("chart");
    chart.ctx = chart.canvas.getContext("2d");
    chart.inner = el("chartInner");
    chart.viewport = el("chartViewport");
    chart.xLabelViewport = el("xLabelsViewport");
    chart.xLabelRow = el("xLabels");

    attachUIEvents();
    attachViewportSelect();

    await loadInsightData();
    if(!APP.loaded){
      // 読めなかった場合でも画面は出す
      initMonths();
      syncAll(true);
    }
  })();</script>
</body>
</html>
